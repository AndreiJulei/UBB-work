     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit               ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    10                                  
    11                                  ; our data is declared here (the variables needed by our program)
    12                                  segment data use32 class=data
    13                                      ; ...
    14                                  	;Problema 15:
    15                                      ;Se da un sir S de dublucuvinte.
    16                                      ;Sa se obtina sirul D format din octetii dublucuvintelor din sirul D sortati in ordine descrescatoare in interpretarea fara semn.
    17                                      
    18 00000000 07563412153C2B1A            s dd 12345607h, 1A2B3C15h
    19                                      len_s equ ($-s)/4
    20                                      
    21 00000008 00<rept>                    d times 4*len_s db 0
    22                                      
    23                                      ; our code starts here
    24                                  segment code use32 class=code
    25                                      start:
    26                                          ; ...
    27 00000000 BE[00000000]                mov esi,s              ; move s in esi so we can work with string instructions
    28 00000005 B902000000                  mov ecx,len_s          ; ecx-number of elements in s
    29 0000000A BF[08000000]                mov edi,d              ; edi-pointer to d
    30 0000000F FC                          cld					   
    31                                  		
    32                                      loop_load:
    33 00000010 AD                              lodsd              ; load the next double word from `s` into the EAX register (EAX = *esi)
    34 00000011 AA                              stosb              ; load the least first significant byte into d
    35 00000012 C1E808                          shr eax,8          ; shift eax to the right with 8 bits so we get the second byte in al
    36 00000015 AA                              stosb               
    37 00000016 C1E808                          shr eax,8
    38 00000019 AA                              stosb
    39 0000001A C1E808                          shr eax,8
    40 0000001D AA                              stosb
    41 0000001E C1E808                          shr eax,8            
    42 00000021 E2ED                        loop loop_load
    43                                      
    44                                      
    45 00000023 B908000000                  mov ecx,4*len_s             ; ecx=length of d
    46 00000028 49                          dec ecx                     ; for bubble sort 
    47                                      
    48                                      bubblesort_outer_loop:
    49 00000029 BF00000000                      mov edi,0                   ; index for esi
    50                                  
    51                                          bubblesort_inner_loop:
    52 0000002E 8A043E                              mov al, [esi + edi]      ; load the current byte
    53 00000031 8A5C3E01                            mov bl, [esi + edi + 1]  ; load the next byte
    54 00000035 38D8                                cmp al, bl               ; compare the two bytes
    55 00000037 7C0A                                jl swap_octets           ; if al < bl, swap the two bytes
    56                                  
    57                                          ; Move to the next pair
    58 00000039 47                              inc edi
    59 0000003A 39CF                            cmp edi, ecx                 ; if edi < ecx go back 
    60 0000003C 7CF0                            jl bubblesort_inner_loop
    61                                          ; Move to outer loop
    62 0000003E 49                              dec ecx
    63 0000003F 75E8                            jnz bubblesort_outer_loop   
    64 00000041 EB0F                            jmp end_
    65                                  
    66                                      swap_octets:
    67                                  
    68 00000043 88C2                    		mov dl,al
    69 00000045 88D8                            mov al,bl
    70 00000047 88D3                            mov bl,dl                       ; swap the two elements
    71 00000049 88043E                          mov [esi + edi], al             ; store the bigger value in al
    72 0000004C 885C3E01                        mov [esi + edi + 1], bl         ; store the smaller value in bl
    73                                          
    74 00000050 EBDC                    	    jmp bubblesort_inner_loop     
    75                                      
    76                                      end_:
    77                                          ; exit(0)
    78 00000052 6A00                            push    dword 0      
    79 00000054 FF15[00000000]                  call    [exit]       
