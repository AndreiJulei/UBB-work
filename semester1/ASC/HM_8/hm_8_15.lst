     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit               ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    10                                  
    11                                  extern exit, printf, scanf ; adaugam printf si scanf ca functii externe           
    12                                  import exit msvcrt.dll     
    13                                  import printf msvcrt.dll     ; indicam asamblorului ca functia printf se gaseste in libraria msvcrt.dll
    14                                  import scanf msvcrt.dll 
    15                                  
    16                                  %include "modul_hm8.asm"			  
     1                              <1> %ifndef _MODUL_HM8_ASM_
     2                              <1> %define _MODUL_HM8_ASM_
     3                              <1> 
     4                              <1> global convert
     5                              <1> 
     6                              <1> convert:
     7                              <1> 			
     8 00000000 31C9                <1> 	xor ecx,ecx
     9                              <1> 		
    10                              <1> 		convert_bits:
    11                              <1> 	
    12 00000002 8A06                <1> 			mov al, byte[esi]           ;move the current byte
    13 00000004 3C30                <1> 			cmp al, "0"                 
    14 00000006 740E                <1> 			jz convert_zero                
    15 00000008 3C31                <1> 			cmp al, "1"                 
    16 0000000A 7402                <1> 			jz convert_one              ;check if the character is "0" or "1"
    17                              <1> 			
    18 0000000C EB10                <1> 			jmp return
    19                              <1> 			
    20                              <1> 		convert_one:
    21                              <1> 			
    22 0000000E D1E1                <1> 			shl ecx,1					
    23 00000010 83C901              <1> 			or ecx,1
    24 00000013 46                  <1> 			inc esi
    25 00000014 EBEC                <1> 		jmp convert_bits
    26                              <1> 				
    27                              <1> 		convert_zero:
    28                              <1> 		
    29 00000016 D1E1                <1> 			shl ecx,1
    30 00000018 83C900              <1> 			or ecx,0
    31 0000001B 46                  <1> 			inc esi
    32 0000001C EBE4                <1> 		jmp convert_bits
    33                              <1> 		
    34                              <1> return:
    35 0000001E C3                  <1> 	ret 
    36                              <1> 	
    37                              <1> %endif
    17                                  ; our data is declared here (the variables needed by our program)
    18                                  segment data use32 class=data
    19                                      ; ...
    20                                  	
    21                                  	;Problem 15:
    22                                  	;A string containing n binary representations on 8 bits is given as a character string.
    23                                  	;Obtain the string containing the numbers corresponding to the given binary representations.
    24                                  	;Example:
    25                                  	;Given: '10100111b', '01100011b', '110b', '101011b'
    26                                  	;Store: 10100111b, 01100011b, 110b, 101011b
    27                                  	
    28                                  
    29 0000001F <res 00000012>          	binary_string resw 9
    30 00000031 <res 00000100>          	result_array resb 256
    31                                  
    32                                  	
    33 00000131 257300                  	format db "%s", 0          
    34 00000134 256400                      format_output db "%d",0
    35 00000137 456E74657220746865-     	input db "Enter the binary string (space separated): ", 0
    35 00000140 2062696E6172792073-
    35 00000149 7472696E6720287370-
    35 00000152 616365207365706172-
    35 0000015B 61746564293A2000   
    36 00000163 546865206172726179-     	final_message db "The array has been stored in binary succesfully!",0
    36 0000016C 20686173206265656E-
    36 00000175 2073746F7265642069-
    36 0000017E 6E2062696E61727920-
    36 00000187 73756363657366756C-
    36 00000190 6C792100           
    37                                  
    38                                  	
    39                                  ; our code starts here
    40                                  segment code use32 class=code
    41                                      start:
    42                                          ; ...
    43                                  	
    44 00000000 68[37010000]            	push dword input
    45 00000005 FF15[00000000]              call [printf]
    46 0000000B 83C404                      add esp, 4
    47                                  	
    48 0000000E BF[31000000]            	mov edi,result_array
    49                                  
    50                                  read_numbers:
    51                                      
    52 00000013 68[1F000000]                push dword binary_string             
    53 00000018 68[31010000]                push dword format    
    54 0000001D FF15[00000000]              call [scanf]
    55 00000023 83C408                      add esp,4*2               
    56                                  
    57 00000026 BE[1F000000]                mov esi,binary_string
    58                                  	
    59                                  	convert_string:
    60                                  		
    61 0000002B 8A06                    		mov al,byte[esi]              ;mov the first byte into al
    62                                  		
    63 0000002D 3C00                    		cmp al, 0                 
    64 0000002F 74E2                    		jz read_numbers                     ;check for the end of the string
    65                                  		
    66 00000031 3C32                    		cmp al,'2'
    67 00000033 741A                    		jz done
    68                                  		
    69 00000035 3C20                    		cmp al,' '					;check if its space
    70 00000037 7406                    		jz skip_space
    71 00000039 3C62                    		cmp al,'b'
    72 0000003B 7402                    		jz skip_space
    73                                  		
    74 0000003D EB03                    		jmp process_bit
    75                                  		
    76                                  		skip_space:
    77 0000003F 46                      			inc esi
    78 00000040 EBE9                    			jmp convert_string        
    79                                  		
    80                                  		process_bit:
    81 00000042 56                      			push esi
    82 00000043 E8(00000000)            			call convert			;convert string to binary and store the result in edi
    83                                  			
    84 00000048 880F                    			mov [edi],cl
    85 0000004A 83C704                  			add edi,4					
    86 0000004D EBC4                    			jmp read_numbers
    87                                  	
    88                                  	
    89                                  	done:
    90 0000004F 68[63010000]            		push dword final_message
    91 00000054 FF15[00000000]          		call [printf]
    92 0000005A 83C404                  		add esp, 4
    93                                  
    94                                          ; exit(0)
    95 0000005D 6A00                            push    dword 0      ; push the parameter for exit onto the stack
    96 0000005F FF15[00000000]                  call    [exit]       ; call exit to terminate the program
